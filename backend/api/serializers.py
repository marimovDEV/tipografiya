from rest_framework import serializers
from django.db import models
from .models import (
    User, Client, Material, Product, Order, ProductionStep, 
    Invoice, PricingSettings, ActivityLog, Transaction,
    Supplier, MaterialBatch, WarehouseLog, SettingsLog,
    EmployeeEfficiency, MachineSettings,
    SystemLock, Calendar, Shift, Reservation, OrderGeometry
)

class OrderGeometrySerializer(serializers.ModelSerializer):
    class Meta:
        model = OrderGeometry
        fields = '__all__'

class PricingSettingsSerializer(serializers.ModelSerializer):
    class Meta:
        model = PricingSettings
        fields = '__all__'


class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=False)
    email = serializers.EmailField(required=False, allow_blank=True)
    first_name = serializers.CharField(required=False, allow_blank=True)
    last_name = serializers.CharField(required=False, allow_blank=True)

    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'first_name', 'last_name', 'role', 'avatar_url', 'password']

    def create(self, validated_data):
        password = validated_data.pop('password', None)
        user = User.objects.create_user(**validated_data)
        if password:
            user.set_password(password)
            user.save()
        return user

    def update(self, instance, validated_data):
        password = validated_data.pop('password', None)
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        
        if password:
            instance.set_password(password)
        
        instance.save()
        return instance

class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=False)
    email = serializers.EmailField(required=False, allow_blank=True)
    first_name = serializers.CharField(required=False, allow_blank=True)
    last_name = serializers.CharField(required=False, allow_blank=True)

    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'first_name', 'last_name', 'role', 'avatar_url', 'password']

    def create(self, validated_data):
        password = validated_data.pop('password', None)
        user = User.objects.create_user(**validated_data)
        if password:
            user.set_password(password)
            user.save()
        return user

    def update(self, instance, validated_data):
        password = validated_data.pop('password', None)
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        
        if password:
            instance.set_password(password)
        
        instance.save()
        return instance

class ClientSerializer(serializers.ModelSerializer):
    balance = serializers.SerializerMethodField()
    
    class Meta:
        model = Client
        fields = '__all__'
        
    def get_balance(self, obj):
        # Calculate balance: Total Payments - Total Orders
        # Negative means debt, Positive means credit
        total_orders = obj.orders.exclude(status='rejected').aggregate(models.Sum('total_price'))['total_price__sum'] or 0
        total_paid = obj.transactions.filter(type='income').aggregate(models.Sum('amount'))['amount__sum'] or 0
        return total_paid - total_orders

class SupplierSerializer(serializers.ModelSerializer):
    class Meta:
        model = Supplier
        fields = '__all__'

class MaterialBatchSerializer(serializers.ModelSerializer):
    supplier_name = serializers.ReadOnlyField(source='supplier.name')
    material_name = serializers.ReadOnlyField(source='material.name')

    class Meta:
        model = MaterialBatch
        fields = '__all__'

class MaterialSerializer(serializers.ModelSerializer):
    batches = MaterialBatchSerializer(many=True, read_only=True)
    available_quantity = serializers.SerializerMethodField()
    available_colors = serializers.SerializerMethodField()
    
    class Meta:
        model = Material
        fields = '__all__'
    
    def get_available_quantity(self, obj):
        """Calculate total available quantity from active batches"""
        batches = MaterialBatch.objects.filter(
            material=obj, 
            is_active=True
        )
        return sum(float(b.current_quantity) for b in batches)
    
    def get_available_colors(self, obj):
        """Get unique colors available for this material"""
        colors = MaterialBatch.objects.filter(
            material=obj,
            is_active=True,
            color__isnull=False
        ).exclude(color='').values_list('color', flat=True).distinct()
        return list(colors)

class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = '__all__'

class WarehouseLogSerializer(serializers.ModelSerializer):
    material_name = serializers.ReadOnlyField(source='material.name')
    product_name = serializers.ReadOnlyField(source='product.name')
    user_name = serializers.ReadOnlyField(source='user.username')
    batch_number = serializers.ReadOnlyField(source='material_batch.batch_number')

    class Meta:
        model = WarehouseLog
        fields = '__all__'

class ProductionStepSerializer(serializers.ModelSerializer):
    assigned_to_name = serializers.SerializerMethodField()
    order_number = serializers.ReadOnlyField(source='order.order_number')
    product_name = serializers.ReadOnlyField(source='order.box_type')
    step_name_display = serializers.CharField(source='get_step_display', read_only=True)
    deadline = serializers.ReadOnlyField(source='order.deadline')
    
    class Meta:
        model = ProductionStep
        fields = '__all__'

    def get_assigned_to_name(self, obj):
        return obj.assigned_to.username if obj.assigned_to else "Biriktirilmagan"

class OrderSerializer(serializers.ModelSerializer):
    client = ClientSerializer(read_only=True)
    client_id = serializers.PrimaryKeyRelatedField(
        queryset=Client.objects.all(), source='client', write_only=True
    )
    production_steps = ProductionStepSerializer(many=True, read_only=True)
    profit = serializers.SerializerMethodField()
    production_time_hours = serializers.SerializerMethodField()
    is_delayed = serializers.SerializerMethodField()
    
    class Meta:
        model = Order
        fields = '__all__'

    def validate(self, data):
        """
        Debt Control Logic: Check if client has exceeded credit limit.
        """
        client = data.get('client')
        # Note: client comes as PK from client_id write_only field, but 'client' read_only field won't be in data on input.
        # We need to get client from the input data.
        
        # In create/update, client is passed via client_id (primary key)
        # DRF automatically looks up the instance for PrimaryKeyRelatedField if passing instance to serializer, 
        # but in 'data' before save it might be just the ID or the object depending on validation stage.
        # Let's check 'client' source='client' write_only field
        
        # 'client' field in Meta is read_only serializer. 'client_id' is write_only.
        # So we look for 'client' from client_id field.
        
        # Actually, for validate(), 'client' key corresponds to the source='client' field from client_id.
        client_obj = data.get('client')
        
        if client_obj:
            current_debt = client_obj.current_debt
            credit_limit = client_obj.credit_limit
            
            # If client is already over limit
            if current_debt > credit_limit:
                 raise serializers.ValidationError({
                    "non_field_errors": [
                        f"DIQQAT: Mijoz qarzdorligi limitdan oshgan! (Qarz: {current_debt:,.0f} / Limit: {credit_limit:,.0f}). Yangi buyurtma yaratish taqiqlanadi."
                    ]
                })
        
        return data

    def get_profit(self, obj):
        if obj.total_price and obj.total_cost:
            return float(obj.total_price - obj.total_cost)
        return None

    def get_production_time_hours(self, obj):
        steps = obj.production_steps.all()
        start = steps.filter(started_at__isnull=False).order_by('started_at').first()
        end = steps.filter(completed_at__isnull=False).order_by('-completed_at').first()
        if start and end and start.started_at and end.completed_at:
            diff = end.completed_at - start.started_at
            return round(diff.total_seconds() / 3600, 1)
        return None

    def get_is_delayed(self, obj):
        if obj.deadline and obj.completed_at:
            return obj.completed_at > obj.deadline
        if obj.deadline and obj.status not in ['completed', 'delivered', 'canceled']:
            from django.utils import timezone
            return timezone.now() > obj.deadline
        return False

    def to_representation(self, instance):
        ret = super().to_representation(instance)
        request = self.context.get('request')
        
        # Hide internal financial data for non-admins/non-accountants
        is_staff = request and request.user.is_authenticated and (request.user.role in ['admin', 'accountant'])
        
        if not is_staff:
            ret.pop('total_cost', None)
            ret.pop('profit', None)
            
        return ret

class InvoiceSerializer(serializers.ModelSerializer):
    order_number = serializers.ReadOnlyField(source='order.order_number')
    client_name = serializers.ReadOnlyField(source='order.client.full_name')

    class Meta:
        model = Invoice
        fields = '__all__'

class ActivityLogSerializer(serializers.ModelSerializer):
    user_name = serializers.ReadOnlyField(source='user.username')
    class Meta:
        model = ActivityLog
        fields = '__all__'

class TransactionSerializer(serializers.ModelSerializer):
    client_name = serializers.ReadOnlyField(source='client.full_name')
    class Meta:
        model = Transaction
        fields = '__all__'

class SettingsLogSerializer(serializers.ModelSerializer):
    user_name = serializers.ReadOnlyField(source='user.username')
    class Meta:
        model = SettingsLog
        fields = '__all__'


class EmployeeEfficiencySerializer(serializers.ModelSerializer):
    employee_name = serializers.ReadOnlyField(source='employee.username')
    employee_full_name = serializers.SerializerMethodField()
    
    class Meta:
        model = EmployeeEfficiency
        fields = '__all__'
    
    def get_employee_full_name(self, obj):
        if obj.employee.first_name or obj.employee.last_name:
            return f"{obj.employee.first_name} {obj.employee.last_name}".strip()
        return obj.employee.username


class MachineSettingsSerializer(serializers.ModelSerializer):
    class Meta:
        model = MachineSettings
        fields = '__all__'


# ========================================
# PHASE 1: INFRASTRUCTURE SERIALIZERS
# ========================================

class SystemLockSerializer(serializers.ModelSerializer):
    locked_by_name = serializers.ReadOnlyField(source='locked_by.username')
    is_expired = serializers.SerializerMethodField()
    
    class Meta:
        model = SystemLock
        fields = '__all__'
    
    def get_is_expired(self, obj):
        from django.utils import timezone
        return obj.expires_at < timezone.now()


class CalendarSerializer(serializers.ModelSerializer):
    day_name = serializers.SerializerMethodField()
    
    class Meta:
        model = Calendar
        fields = '__all__'
    
    def get_day_name(self, obj):
        days = ['Dushanba', 'Seshanba', 'Chorshanba', 'Payshanba', 'Juma', 'Shanba', 'Yakshanba']
        return days[obj.date.weekday()]


class ShiftSerializer(serializers.ModelSerializer):
    duration_hours = serializers.ReadOnlyField()
    
    class Meta:
        model = Shift
        fields = '__all__'


class ReservationSerializer(serializers.ModelSerializer):
    material_name = serializers.ReadOnlyField(source='material.name')
    batch_number = serializers.ReadOnlyField(source='material_batch.batch_number')
    order_number = serializers.ReadOnlyField(source='order.order_number')
    
    class Meta:
        model = Reservation
        fields = '__all__'

